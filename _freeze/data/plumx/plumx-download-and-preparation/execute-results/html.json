{
  "hash": "a5d72f905e58294050819a239a516abc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Download and prepare data from PlumX API\"\nengine: knitr\n---\n\nFirst we select the list of DOIs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(RefManageR)\nlibrary(purrr)\nlibrary(foreach)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'foreach'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:purrr':\n\n    accumulate, when\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(jsonlite)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'jsonlite'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:purrr':\n\n    flatten\n```\n\n\n:::\n\n```{.r .cell-code}\nhere::i_am(\"data/plumx/plumx-download-and-preparation.qmd\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nhere() starts at /Users/z3529065/proyectos/personal/espa√±ol\n```\n\n\n:::\n\n```{.r .cell-code}\nbib1 <- ReadBib(here::here(\"bibTeX\",\"peer-review.bibtex\"), check = FALSE)\n\nCRediT_folder <- \"data\"\ncredit <-read_excel(here::here(CRediT_folder, \"CRediT-my-publications.xlsx\"), \n                    \"Contributions per pub\") \ndois <- credit |> filter(!is.na(doi)) |> pull(doi)\n\nconn <- file(here::here(\"data/plumx/\",\"doi-list\"), \"w\")\nwriteLines(dois,conn)\nclose(conn)\n```\n:::\n\n\nNow we run this to query plumx API (need to run this in the UNSW network to get access to the service, VPN is not enough):\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nsource ~/.Renviron\n\nfor doi in $(cat doi-list)\ndo\n  sdoi=query-$(echo $doi | sed -e s/\\\\//_/g).json\n  if [ -e $sdoi ]\n  then\n      echo \"skipping $doi\"\n  else\n      wget --output-document=${sdoi} https://api.elsevier.com/analytics/plumx/doi/${doi}?apiKey=${Elsevier_API}\n  fi\ndone\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nskipping 10.1038/s41598-024-52133-0\nskipping 10.1038/s41559-023-02320-5\nskipping 10.1016/j.ecolind.2024.111790\nskipping 10.1111/cobi.13995\nskipping 10.1111/cobi.14169\nskipping 10.1038/s41467-023-43760-8\nskipping 10.35249/rche.48.2.22.05\nskipping 10.1093/ornithology/ukab076\nskipping 10.1038/s41586-022-05318-4\nskipping 10.3390/d13050191\nskipping 10.7717/peerj.11612\nskipping 10.3390/d13120611\nskipping 10.21068/A2022FSNIX.13\nskipping 10.1186/s42522-021-00036-9\nskipping 10.1111/conl.12680\nskipping 10.1017/S0959270919000522\nskipping 10.12933/therya-20-891\nskipping 10.1016/j.biocon.2020.108834\nskipping 10.2305/IUCN.CH.2020.13.en\nskipping 10.1111/conl.12623\nskipping 10.1111/conl.12666\nskipping 10.1002/ece3.3628\nskipping 10.1016/s1002-0160(18)60029-3\nskipping 10.12933/therya-18-616\nskipping 10.1016/j.biocon.2016.09.027\nskipping 10.1016/j.prevetmed.2016.11.023\nskipping 10.1007/s10841-016-9886-6\nskipping 10.1016/j.jaridenv.2016.04.007\nskipping 10.1111/acv.12106\nskipping 10.1016/j.biocon.2013.07.032\nskipping 10.1371/journal.pone.0110236\nskipping 10.1371/journal.pone.0063570\nskipping 10.1111/ddi.12012\nskipping 10.15517/rbt.v61i1.10941\nskipping 10.1676/11-057.1\nskipping 10.1017/S0030605308006996\nskipping 10.1098/rsbl.2003.0015\nskipping 10.1002/ece3.11404\n```\n\n\n:::\n:::\n\n\n\nLet's wrap the process in a couple of functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  tibble(!!x$name := x$total) \n}\nreadPlumxJson <- function(x) {\n  if(file.info(x)$size>0) {\n    qry <- read_json(x)\n  vls <- map(qry$count_categories, \n             function(x) {\n               totals <- f(x) \n               counts <- map(x$count_types,f)\n               bind_cols(totals, counts)\n             }) |> bind_cols()\n  rslts <- tibble(doi = qry$id_value) %>% bind_cols(vls)\n  }\n  else {\n    rslts <- tibble()\n  }\n  rslts\n}\n```\n:::\n\n\nRead files from folder and `map` function:\n\n::: {.cell}\n\n```{.r .cell-code}\nplumx_folder <- here::here(\"data/plumx/\")\njsonFiles <- dir(plumx_folder, pattern = \"json$\", full.names = TRUE)\nPMX_ALL <- map(jsonFiles, readPlumxJson) |> bind_rows()\n```\n:::\n\n\nSave this to a folder:\n\n::: {.cell}\n\n```{.r .cell-code}\nrds_folder <- \"data\"\nsaveRDS(PMX_ALL,here::here(rds_folder,\"plumx_ALL.rds\")) \n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}